import { ChangeDetectorRef, Directive, ElementRef, Inject, Input, Optional, Renderer2, TemplateRef, ViewContainerRef, } from '@angular/core';
import { forkJoin } from 'rxjs';
import { switchMap } from 'rxjs/operators';
import { TemplateHandler } from './template-handler';
import { TRANSLOCO_LANG } from './transloco-lang';
import { TRANSLOCO_LOADING_TEMPLATE } from './transloco-loading-template';
import { TRANSLOCO_SCOPE } from './transloco-scope';
import { TranslocoService } from './transloco.service';
import { listenOrNotOperator, resolveInlineLoader, shouldListenToLangChanges, } from './shared';
import { LangResolver } from './lang-resolver';
import { ScopeResolver } from './scope-resolver';
import * as i0 from "@angular/core";
import * as i1 from "./transloco.service";
export class TranslocoDirective {
    constructor(translocoService, tpl, providerScope, providerLang, providedLoadingTpl, vcr, cdr, host, renderer) {
        this.translocoService = translocoService;
        this.tpl = tpl;
        this.providerScope = providerScope;
        this.providerLang = providerLang;
        this.providedLoadingTpl = providedLoadingTpl;
        this.vcr = vcr;
        this.cdr = cdr;
        this.host = host;
        this.renderer = renderer;
        this.subscription = null;
        this.translationMemo = {};
        this.params = {};
        // Whether we already rendered the view once
        this.initialized = false;
        this.langResolver = new LangResolver();
        this.scopeResolver = new ScopeResolver(this.translocoService);
    }
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    ngOnInit() {
        const listenToLangChange = shouldListenToLangChanges(this.translocoService, this.providerLang || this.inlineLang);
        this.subscription = this.translocoService.langChanges$
            .pipe(switchMap((activeLang) => {
            const lang = this.langResolver.resolve({
                inline: this.inlineLang,
                provider: this.providerLang,
                active: activeLang,
            });
            return Array.isArray(this.providerScope)
                ? forkJoin(this.providerScope.map((providerScope) => this.resolveScope(lang, providerScope)))
                : this.resolveScope(lang, this.providerScope);
        }), listenOrNotOperator(listenToLangChange))
            .subscribe(() => {
            this.currentLang = this.langResolver.resolveLangBasedOnScope(this.path);
            this.tpl === null
                ? this.simpleStrategy()
                : this.structuralStrategy(this.currentLang, this.inlineRead);
            this.cdr.markForCheck();
            this.initialized = true;
        });
        const loadingTpl = this.getLoadingTpl();
        if (!this.initialized && loadingTpl) {
            this.loaderTplHandler = new TemplateHandler(loadingTpl, this.vcr);
            this.loaderTplHandler.attachView();
        }
    }
    ngOnChanges(changes) {
        // We need to support dynamic keys/params, so if this is not the first change CD cycle
        // we need to run the function again in order to update the value
        const notInit = Object.keys(changes).some((v) => !changes[v].firstChange);
        notInit && this.simpleStrategy();
    }
    simpleStrategy() {
        this.detachLoader();
        this.renderer.setProperty(this.host.nativeElement, 'innerText', this.translocoService.translate(this.key, this.params, this.currentLang));
    }
    structuralStrategy(lang, read) {
        this.translationMemo = {};
        if (this.view) {
            // when the lang changes we need to change the reference so Angular will update the view
            this.view.context['$implicit'] = this.getTranslateFn(lang, read);
            this.view.context['currentLang'] = this.currentLang;
        }
        else {
            this.detachLoader();
            this.view = this.vcr.createEmbeddedView(this.tpl, {
                $implicit: this.getTranslateFn(lang, read),
                currentLang: this.currentLang,
            });
        }
    }
    getTranslateFn(lang, read) {
        return (key, params) => {
            const withRead = read ? `${read}.${key}` : key;
            const withParams = params
                ? `${withRead}${JSON.stringify(params)}`
                : withRead;
            if (Object.prototype.hasOwnProperty.call(this.translationMemo, withParams)) {
                return this.translationMemo[withParams].value;
            }
            this.translationMemo[withParams] = {
                params,
                value: this.translocoService.translate(withRead, params, lang),
            };
            return this.translationMemo[withParams].value;
        };
    }
    getLoadingTpl() {
        return this.inlineTpl || this.providedLoadingTpl;
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
            // Caretaker note: it's important to clean up references to subscriptions since they save the `next`
            // callback within its `destination` property, preventing classes from being GC'd.
            this.subscription = null;
        }
    }
    detachLoader() {
        var _a;
        (_a = this.loaderTplHandler) === null || _a === void 0 ? void 0 : _a.detachView();
    }
    resolveScope(lang, providerScope) {
        const resolvedScope = this.scopeResolver.resolve({
            inline: this.inlineScope,
            provider: providerScope,
        });
        this.path = this.langResolver.resolveLangPath(lang, resolvedScope);
        const inlineLoader = resolveInlineLoader(providerScope, resolvedScope);
        return this.translocoService._loadDependencies(this.path, inlineLoader);
    }
}
TranslocoDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoDirective, deps: [{ token: i1.TranslocoService }, { token: i0.TemplateRef, optional: true }, { token: TRANSLOCO_SCOPE, optional: true }, { token: TRANSLOCO_LANG, optional: true }, { token: TRANSLOCO_LOADING_TEMPLATE, optional: true }, { token: i0.ViewContainerRef }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive });
TranslocoDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "12.2.5", type: TranslocoDirective, selector: "[transloco]", inputs: { key: ["transloco", "key"], params: ["translocoParams", "params"], inlineScope: ["translocoScope", "inlineScope"], inlineRead: ["translocoRead", "inlineRead"], inlineLang: ["translocoLang", "inlineLang"], inlineTpl: ["translocoLoadingTpl", "inlineTpl"] }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.5", ngImport: i0, type: TranslocoDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[transloco]',
                }]
        }], ctorParameters: function () { return [{ type: i1.TranslocoService }, { type: i0.TemplateRef, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_SCOPE]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LANG]
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [TRANSLOCO_LOADING_TEMPLATE]
                }] }, { type: i0.ViewContainerRef }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { key: [{
                type: Input,
                args: ['transloco']
            }], params: [{
                type: Input,
                args: ['translocoParams']
            }], inlineScope: [{
                type: Input,
                args: ['translocoScope']
            }], inlineRead: [{
                type: Input,
                args: ['translocoRead']
            }], inlineLang: [{
                type: Input,
                args: ['translocoLang']
            }], inlineTpl: [{
                type: Input,
                args: ['translocoLoadingTpl']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNsb2NvLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL2xpYnMvdHJhbnNsb2NvL3NyYy9saWIvdHJhbnNsb2NvLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBRVYsTUFBTSxFQUNOLEtBQUssRUFJTCxRQUFRLEVBQ1IsU0FBUyxFQUVULFdBQVcsRUFFWCxnQkFBZ0IsR0FDakIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFFBQVEsRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQVEsTUFBTSxvQkFBb0IsQ0FBQztBQUMzRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbEQsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sOEJBQThCLENBQUM7QUFDMUUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXZELE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsbUJBQW1CLEVBQ25CLHlCQUF5QixHQUMxQixNQUFNLFVBQVUsQ0FBQztBQUNsQixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7QUFXakQsTUFBTSxPQUFPLGtCQUFrQjtJQTZCN0IsWUFDVSxnQkFBa0MsRUFDdEIsR0FBNkIsRUFHekMsYUFBeUMsRUFHekMsWUFBZ0MsRUFHaEMsa0JBQTBDLEVBQzFDLEdBQXFCLEVBQ3JCLEdBQXNCLEVBQ3RCLElBQWdCLEVBQ2hCLFFBQW1CO1FBZG5CLHFCQUFnQixH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S0FBSzt1QkFBQyxlQUFlO2dCQUNFLFVBQVU7c0JBQWpDLEtBQUs7dUJBQUMsZUFBZTtnQkFDUSxTQUFTO3NCQUF0QyxLQUFLO3VCQUFDLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBEaXJlY3RpdmUsXG4gIEVsZW1lbnRSZWYsXG4gIEVtYmVkZGVkVmlld1JlZixcbiAgSW5qZWN0LFxuICBJbnB1dCxcbiAgT25DaGFuZ2VzLFxuICBPbkRlc3Ryb3ksXG4gIE9uSW5pdCxcbiAgT3B0aW9uYWwsXG4gIFJlbmRlcmVyMixcbiAgU2ltcGxlQ2hhbmdlcyxcbiAgVGVtcGxhdGVSZWYsXG4gIFR5cGUsXG4gIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZm9ya0pvaW4sIE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVGVtcGxhdGVIYW5kbGVyLCBWaWV3IH0gZnJvbSAnLi90ZW1wbGF0ZS1oYW5kbGVyJztcbmltcG9ydCB7IFRSQU5TTE9DT19MQU5HIH0gZnJvbSAnLi90cmFuc2xvY28tbGFuZyc7XG5pbXBvcnQgeyBUUkFOU0xPQ09fTE9BRElOR19URU1QTEFURSB9IGZyb20gJy4vdHJhbnNsb2NvLWxvYWRpbmctdGVtcGxhdGUnO1xuaW1wb3J0IHsgVFJBTlNMT0NPX1NDT1BFIH0gZnJvbSAnLi90cmFuc2xvY28tc2NvcGUnO1xuaW1wb3J0IHsgVHJhbnNsb2NvU2VydmljZSB9IGZyb20gJy4vdHJhbnNsb2NvLnNlcnZpY2UnO1xuaW1wb3J0IHsgSGFzaE1hcCwgTWF5YmVBcnJheSwgVHJhbnNsYXRpb24sIFRyYW5zbG9jb1Njb3BlIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQge1xuICBsaXN0ZW5Pck5vdE9wZXJhdG9yLFxuICByZXNvbHZlSW5saW5lTG9hZGVyLFxuICBzaG91bGRMaXN0ZW5Ub0xhbmdDaGFuZ2VzLFxufSBmcm9tICcuL3NoYXJlZCc7XG5pbXBvcnQgeyBMYW5nUmVzb2x2ZXIgfSBmcm9tICcuL2xhbmctcmVzb2x2ZXInO1xuaW1wb3J0IHsgU2NvcGVSZXNvbHZlciB9IGZyb20gJy4vc2NvcGUtcmVzb2x2ZXInO1xuXG50eXBlIFRyYW5zbGF0ZUZuID0gKGtleTogc3RyaW5nLCBwYXJhbXM/OiBIYXNoTWFwKSA9PiBhbnk7XG5pbnRlcmZhY2UgVmlld0NvbnRleHQge1xuICAkaW1wbGljaXQ6IFRyYW5zbGF0ZUZuO1xuICBjdXJyZW50TGFuZzogc3RyaW5nO1xufVxuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdHJhbnNsb2NvXScsXG59KVxuZXhwb3J0IGNsYXNzIFRyYW5zbG9jb0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMge1xuICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiB8IG51bGwgPSBudWxsO1xuICB2aWV3OiBFbWJlZGRlZFZpZXdSZWY8Vmlld0NvbnRleHQ+IHwgdW5kZWZpbmVkO1xuXG4gIHByaXZhdGUgdHJhbnNsYXRpb25NZW1vOiBSZWNvcmQ8c3RyaW5nLCB7IHZhbHVlOiBhbnk7IHBhcmFtcz86IEhhc2hNYXAgfT4gPVxuICAgIHt9O1xuXG4gIEBJbnB1dCgndHJhbnNsb2NvJykga2V5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIEBJbnB1dCgndHJhbnNsb2NvUGFyYW1zJykgcGFyYW1zOiBIYXNoTWFwID0ge307XG4gIEBJbnB1dCgndHJhbnNsb2NvU2NvcGUnKSBpbmxpbmVTY29wZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBASW5wdXQoJ3RyYW5zbG9jb1JlYWQnKSBpbmxpbmVSZWFkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIEBJbnB1dCgndHJhbnNsb2NvTGFuZycpIGlubGluZUxhbmc6IHN0cmluZyB8IHVuZGVmaW5lZDtcbiAgQElucHV0KCd0cmFuc2xvY29Mb2FkaW5nVHBsJykgaW5saW5lVHBsOiBUZW1wbGF0ZVJlZjx1bmtub3duPiB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGN1cnJlbnRMYW5nOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIHByaXZhdGUgbG9hZGVyVHBsSGFuZGxlcjogVGVtcGxhdGVIYW5kbGVyIHwgdW5kZWZpbmVkO1xuICAvLyBXaGV0aGVyIHdlIGFscmVhZHkgcmVuZGVyZWQgdGhlIHZpZXcgb25jZVxuICBwcml2YXRlIGluaXRpYWxpemVkID0gZmFsc2U7XG4gIHByaXZhdGUgcGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwcml2YXRlIGxhbmdSZXNvbHZlciA9IG5ldyBMYW5nUmVzb2x2ZXIoKTtcbiAgcHJpdmF0ZSBzY29wZVJlc29sdmVyID0gbmV3IFNjb3BlUmVzb2x2ZXIodGhpcy50cmFuc2xvY29TZXJ2aWNlKTtcblxuICBzdGF0aWMgbmdUZW1wbGF0ZUNvbnRleHRHdWFyZChcbiAgICBkaXI6IFRyYW5zbG9jb0RpcmVjdGl2ZSxcbiAgICBjdHg6IHVua25vd25cbiAgKTogY3R4IGlzIFZpZXdDb250ZXh0IHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdHJhbnNsb2NvU2VydmljZTogVHJhbnNsb2NvU2VydmljZSxcbiAgICBAT3B0aW9uYWwoKSBwcml2YXRlIHRwbDogVGVtcGxhdGVSZWY8Vmlld0NvbnRleHQ+LFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChUUkFOU0xPQ09fU0NPUEUpXG4gICAgcHJpdmF0ZSBwcm92aWRlclNjb3BlOiBNYXliZUFycmF5PFRyYW5zbG9jb1Njb3BlPixcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0xBTkcpXG4gICAgcHJpdmF0ZSBwcm92aWRlckxhbmc6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBJbmplY3QoVFJBTlNMT0NPX0xPQURJTkdfVEVNUExBVEUpXG4gICAgcHJpdmF0ZSBwcm92aWRlZExvYWRpbmdUcGw6IFR5cGU8dW5rbm93bj4gfCBzdHJpbmcsXG4gICAgcHJpdmF0ZSB2Y3I6IFZpZXdDb250YWluZXJSZWYsXG4gICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIHByaXZhdGUgaG9zdDogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgKSB7fVxuXG4gIG5nT25Jbml0KCkge1xuICAgIGNvbnN0IGxpc3RlblRvTGFuZ0NoYW5nZSA9IHNob3VsZExpc3RlblRvTGFuZ0NoYW5nZXMoXG4gICAgICB0aGlzLnRyYW5zbG9jb1NlcnZpY2UsXG4gICAgICB0aGlzLnByb3ZpZGVyTGFuZyB8fCB0aGlzLmlubGluZUxhbmdcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb24gPSB0aGlzLnRyYW5zbG9jb1NlcnZpY2UubGFuZ0NoYW5nZXMkXG4gICAgICAucGlwZShcbiAgICAgICAgc3dpdGNoTWFwKChhY3RpdmVMYW5nKSA9PiB7XG4gICAgICAgICAgY29uc3QgbGFuZyA9IHRoaXMubGFuZ1Jlc29sdmVyLnJlc29sdmUoe1xuICAgICAgICAgICAgaW5saW5lOiB0aGlzLmlubGluZUxhbmcsXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlckxhbmcsXG4gICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZUxhbmcsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnByb3ZpZGVyU2NvcGUpXG4gICAgICAgICAgICA/IGZvcmtKb2luKFxuICAgICAgICAgICAgICAgICg8VHJhbnNsb2NvU2NvcGVbXT50aGlzLnByb3ZpZGVyU2NvcGUpLm1hcCgocHJvdmlkZXJTY29wZSkgPT5cbiAgICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZVNjb3BlKGxhbmcsIHByb3ZpZGVyU2NvcGUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHRoaXMucmVzb2x2ZVNjb3BlKGxhbmcsIHRoaXMucHJvdmlkZXJTY29wZSk7XG4gICAgICAgIH0pLFxuICAgICAgICBsaXN0ZW5Pck5vdE9wZXJhdG9yKGxpc3RlblRvTGFuZ0NoYW5nZSlcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLmN1cnJlbnRMYW5nID0gdGhpcy5sYW5nUmVzb2x2ZXIucmVzb2x2ZUxhbmdCYXNlZE9uU2NvcGUoXG4gICAgICAgICAgdGhpcy5wYXRoIVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnRwbCA9PT0gbnVsbFxuICAgICAgICAgID8gdGhpcy5zaW1wbGVTdHJhdGVneSgpXG4gICAgICAgICAgOiB0aGlzLnN0cnVjdHVyYWxTdHJhdGVneSh0aGlzLmN1cnJlbnRMYW5nLCB0aGlzLmlubGluZVJlYWQpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB9KTtcblxuICAgIGNvbnN0IGxvYWRpbmdUcGwgPSB0aGlzLmdldExvYWRpbmdUcGwoKTtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQgJiYgbG9hZGluZ1RwbCkge1xuICAgICAgdGhpcy5sb2FkZXJUcGxIYW5kbGVyID0gbmV3IFRlbXBsYXRlSGFuZGxlcihsb2FkaW5nVHBsLCB0aGlzLnZjcik7XG4gICAgICB0aGlzLmxvYWRlclRwbEhhbmRsZXIuYXR0YWNoVmlldygpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHN1cHBvcnQgZHluYW1pYyBrZXlzL3BhcmFtcywgc28gaWYgdGhpcyBpcyBub3QgdGhlIGZpcnN0IGNoYW5nZSBDRCBjeWNsZVxuICAgIC8vIHdlIG5lZWQgdG8gcnVuIHRoZSBmdW5jdGlvbiBhZ2FpbiBpbiBvcmRlciB0byB1cGRhdGUgdGhlIHZhbHVlXG4gICAgY29uc3Qgbm90SW5pdCA9IE9iamVjdC5rZXlzKGNoYW5nZXMpLnNvbWUoKHYpID0+ICFjaGFuZ2VzW3ZdLmZpcnN0Q2hhbmdlKTtcbiAgICBub3RJbml0ICYmIHRoaXMuc2ltcGxlU3RyYXRlZ3koKTtcbiAgfVxuXG4gIHByaXZhdGUgc2ltcGxlU3RyYXRlZ3koKSB7XG4gICAgdGhpcy5kZXRhY2hMb2FkZXIoKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFByb3BlcnR5KFxuICAgICAgdGhpcy5ob3N0Lm5hdGl2ZUVsZW1lbnQsXG4gICAgICAnaW5uZXJUZXh0JyxcbiAgICAgIHRoaXMudHJhbnNsb2NvU2VydmljZS50cmFuc2xhdGUodGhpcy5rZXkhLCB0aGlzLnBhcmFtcywgdGhpcy5jdXJyZW50TGFuZylcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdHJ1Y3R1cmFsU3RyYXRlZ3kobGFuZzogc3RyaW5nLCByZWFkPzogc3RyaW5nKSB7XG4gICAgdGhpcy50cmFuc2xhdGlvbk1lbW8gPSB7fTtcblxuICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgIC8vIHdoZW4gdGhlIGxhbmcgY2hhbmdlcyB3ZSBuZWVkIHRvIGNoYW5nZSB0aGUgcmVmZXJlbmNlIHNvIEFuZ3VsYXIgd2lsbCB1cGRhdGUgdGhlIHZpZXdcbiAgICAgIHRoaXMudmlldy5jb250ZXh0WyckaW1wbGljaXQnXSA9IHRoaXMuZ2V0VHJhbnNsYXRlRm4obGFuZywgcmVhZCk7XG4gICAgICB0aGlzLnZpZXcuY29udGV4dFsnY3VycmVudExhbmcnXSA9IHRoaXMuY3VycmVudExhbmchO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRldGFjaExvYWRlcigpO1xuICAgICAgdGhpcy52aWV3ID0gdGhpcy52Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMudHBsLCB7XG4gICAgICAgICRpbXBsaWNpdDogdGhpcy5nZXRUcmFuc2xhdGVGbihsYW5nLCByZWFkKSxcbiAgICAgICAgY3VycmVudExhbmc6IHRoaXMuY3VycmVudExhbmchLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGdldFRyYW5zbGF0ZUZuKFxuICAgIGxhbmc6IHN0cmluZyxcbiAgICByZWFkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgKTogVHJhbnNsYXRlRm4ge1xuICAgIHJldHVybiAoa2V5OiBzdHJpbmcsIHBhcmFtcz86IEhhc2hNYXApID0+IHtcbiAgICAgIGNvbnN0IHdpdGhSZWFkID0gcmVhZCA/IGAke3JlYWR9LiR7a2V5fWAgOiBrZXk7XG4gICAgICBjb25zdCB3aXRoUGFyYW1zID0gcGFyYW1zXG4gICAgICAgID8gYCR7d2l0aFJlYWR9JHtKU09OLnN0cmluZ2lmeShwYXJhbXMpfWBcbiAgICAgICAgOiB3aXRoUmVhZDtcblxuICAgICAgaWYgKFxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy50cmFuc2xhdGlvbk1lbW8sIHdpdGhQYXJhbXMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRpb25NZW1vW3dpdGhQYXJhbXNdLnZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyYW5zbGF0aW9uTWVtb1t3aXRoUGFyYW1zXSA9IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICB2YWx1ZTogdGhpcy50cmFuc2xvY29TZXJ2aWNlLnRyYW5zbGF0ZSh3aXRoUmVhZCwgcGFyYW1zLCBsYW5nKSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0aW9uTWVtb1t3aXRoUGFyYW1zXS52YWx1ZTtcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRMb2FkaW5nVHBsKCk6IFZpZXcge1xuICAgIHJldHVybiB0aGlzLmlubGluZVRwbCB8fCB0aGlzLnByb3ZpZGVkTG9hZGluZ1RwbDtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIC8vIENhcmV0YWtlciBub3RlOiBpdCdzIGltcG9ydGFudCB0byBjbGVhbiB1cCByZWZlcmVuY2VzIHRvIHN1YnNjcmlwdGlvbnMgc2luY2UgdGhleSBzYXZlIHRoZSBgbmV4dGBcbiAgICAgIC8vIGNhbGxiYWNrIHdpdGhpbiBpdHMgYGRlc3RpbmF0aW9uYCBwcm9wZXJ0eSwgcHJldmVudGluZyBjbGFzc2VzIGZyb20gYmVpbmcgR0MnZC5cbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRldGFjaExvYWRlcigpIHtcbiAgICB0aGlzLmxvYWRlclRwbEhhbmRsZXI/LmRldGFjaFZpZXcoKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzb2x2ZVNjb3BlKFxuICAgIGxhbmc6IHN0cmluZyxcbiAgICBwcm92aWRlclNjb3BlOiBUcmFuc2xvY29TY29wZVxuICApOiBPYnNlcnZhYmxlPFRyYW5zbGF0aW9uIHwgVHJhbnNsYXRpb25bXT4ge1xuICAgIGNvbnN0IHJlc29sdmVkU2NvcGUgPSB0aGlzLnNjb3BlUmVzb2x2ZXIucmVzb2x2ZSh7XG4gICAgICBpbmxpbmU6IHRoaXMuaW5saW5lU2NvcGUsXG4gICAgICBwcm92aWRlcjogcHJvdmlkZXJTY29wZSxcbiAgICB9KTtcbiAgICB0aGlzLnBhdGggPSB0aGlzLmxhbmdSZXNvbHZlci5yZXNvbHZlTGFuZ1BhdGgobGFuZywgcmVzb2x2ZWRTY29wZSk7XG4gICAgY29uc3QgaW5saW5lTG9hZGVyID0gcmVzb2x2ZUlubGluZUxvYWRlcihwcm92aWRlclNjb3BlLCByZXNvbHZlZFNjb3BlKTtcblxuICAgIHJldHVybiB0aGlzLnRyYW5zbG9jb1NlcnZpY2UuX2xvYWREZXBlbmRlbmNpZXModGhpcy5wYXRoLCBpbmxpbmVMb2FkZXIpO1xuICB9XG59XG4iXX0=